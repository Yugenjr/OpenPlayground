<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Quest - Dungeon Adventure</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            padding: 15px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            border: 2px solid #4cc9f0;
        }

        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #4cc9f0, #f72585);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            font-size: 1.2rem;
            color: #b8c1ec;
            margin-bottom: 15px;
        }

        .game-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            width: 100%;
        }

        .game-board-container {
            flex: 1;
            min-width: 500px;
            max-width: 700px;
        }

        .game-info {
            flex: 1;
            min-width: 300px;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            border: 2px solid #f72585;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 25px;
        }

        .stat-card {
            background: rgba(76, 201, 240, 0.1);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            border: 1px solid #4cc9f0;
        }

        .stat-card h3 {
            font-size: 1rem;
            color: #b8c1ec;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #fff;
        }

        .controls {
            margin-top: 25px;
        }

        .controls h2 {
            color: #f72585;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .control-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(90deg, #4361ee, #3a0ca3);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(90deg, #3a0ca3, #4361ee);
            transform: translateY(-3px);
            box-shadow: 0 5px 10px rgba(67, 97, 238, 0.4);
        }

        .btn-danger {
            background: linear-gradient(90deg, #f72585, #b5179e);
            color: white;
        }

        .btn-danger:hover {
            background: linear-gradient(90deg, #b5179e, #f72585);
            transform: translateY(-3px);
            box-shadow: 0 5px 10px rgba(247, 37, 133, 0.4);
        }

        .btn-success {
            background: linear-gradient(90deg, #4cc9f0, #4895ef);
            color: white;
        }

        .btn-success:hover {
            background: linear-gradient(90deg, #4895ef, #4cc9f0);
            transform: translateY(-3px);
            box-shadow: 0 5px 10px rgba(76, 201, 240, 0.4);
        }

        .instructions {
            margin-top: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border-left: 5px solid #4cc9f0;
        }

        .instructions h3 {
            color: #4cc9f0;
            margin-bottom: 10px;
        }

        .instructions ul {
            padding-left: 20px;
            color: #b8c1ec;
        }

        .instructions li {
            margin-bottom: 8px;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            gap: 2px;
            width: 100%;
            aspect-ratio: 1/1;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.7);
            border: 3px solid #4cc9f0;
            margin-bottom: 20px;
        }

        .cell {
            background-color: #2d3047;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .cell.player {
            background-color: #4cc9f0;
            box-shadow: 0 0 10px #4cc9f0;
        }

        .cell.gem {
            background-color: #ffd166;
            box-shadow: 0 0 10px #ffd166;
        }

        .cell.monster {
            background-color: #f72585;
            box-shadow: 0 0 10px #f72585;
        }

        .cell.wall {
            background-color: #3a506b;
        }

        .cell.exit {
            background-color: #06d6a0;
            box-shadow: 0 0 10px #06d6a0;
            animation: pulse 2s infinite;
        }

        .cell.empty {
            background-color: #2d3047;
        }

        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        .game-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 100;
            display: none;
            box-shadow: 0 0 30px rgba(76, 201, 240, 0.5);
            border: 3px solid #4cc9f0;
            max-width: 500px;
            width: 90%;
        }

        .game-message h2 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #f72585;
        }

        .game-message p {
            font-size: 1.2rem;
            margin-bottom: 25px;
            color: #b8c1ec;
        }

        .mobile-controls {
            display: none;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 10px;
            margin-top: 20px;
            width: 100%;
            max-width: 300px;
        }

        .mobile-btn {
            background: rgba(76, 201, 240, 0.2);
            border: 2px solid #4cc9f0;
            color: white;
            font-size: 1.5rem;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            cursor: pointer;
            user-select: none;
        }

        .mobile-btn:active {
            background: rgba(76, 201, 240, 0.5);
        }

        #up-btn {
            grid-column: 2;
            grid-row: 1;
        }

        #left-btn {
            grid-column: 1;
            grid-row: 2;
        }

        #right-btn {
            grid-column: 3;
            grid-row: 2;
        }

        #down-btn {
            grid-column: 2;
            grid-row: 2;
        }

        #action-btn {
            grid-column: 1 / span 3;
            grid-row: 3;
            background: rgba(247, 37, 133, 0.2);
            border: 2px solid #f72585;
        }

        #action-btn:active {
            background: rgba(247, 37, 133, 0.5);
        }

        @media (max-width: 1000px) {
            .game-area {
                flex-direction: column;
                align-items: center;
            }
            
            .game-board-container, .game-info {
                min-width: 90%;
                max-width: 90%;
            }
        }

        @media (max-width: 600px) {
            .game-board {
                grid-template-columns: repeat(15, 1fr);
                grid-template-rows: repeat(15, 1fr);
            }
            
            .mobile-controls {
                display: grid;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .stat-value {
                font-size: 1.5rem;
            }
        }

        footer {
            margin-top: 30px;
            text-align: center;
            color: #b8c1ec;
            font-size: 0.9rem;
            padding: 15px;
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-gamepad"></i> Pixel Quest</h1>
            <p class="subtitle">A dungeon adventure game. Collect gems, avoid monsters, find the exit!</p>
        </header>

        <div class="game-area">
            <div class="game-board-container">
                <div class="game-board" id="gameBoard"></div>
                
                <div class="mobile-controls">
                    <div class="mobile-btn" id="up-btn"><i class="fas fa-arrow-up"></i></div>
                    <div class="mobile-btn" id="left-btn"><i class="fas fa-arrow-left"></i></div>
                    <div class="mobile-btn" id="down-btn"><i class="fas fa-arrow-down"></i></div>
                    <div class="mobile-btn" id="right-btn"><i class="fas fa-arrow-right"></i></div>
                    <div class="mobile-btn" id="action-btn"><i class="fas fa-bolt"></i> Action</div>
                </div>
            </div>
            
            <div class="game-info">
                <div class="stats">
                    <div class="stat-card">
                        <h3><i class="fas fa-gem"></i> Gems Collected</h3>
                        <div class="stat-value" id="gemCount">0</div>
                    </div>
                    <div class="stat-card">
                        <h3><i class="fas fa-heart"></i> Health</h3>
                        <div class="stat-value" id="healthCount">100</div>
                    </div>
                    <div class="stat-card">
                        <h3><i class="fas fa-bolt"></i> Moves</h3>
                        <div class="stat-value" id="moveCount">0</div>
                    </div>
                    <div class="stat-card">
                        <h3><i class="fas fa-skull-crossbones"></i> Monsters</h3>
                        <div class="stat-value" id="monsterCount">5</div>
                    </div>
                </div>
                
                <div class="controls">
                    <h2><i class="fas fa-cogs"></i> Game Controls</h2>
                    <div class="control-buttons">
                        <button class="btn btn-primary" id="newGameBtn">
                            <i class="fas fa-plus-circle"></i> New Game
                        </button>
                        <button class="btn btn-success" id="hintBtn">
                            <i class="fas fa-lightbulb"></i> Show Hint
                        </button>
                        <button class="btn btn-danger" id="resetBtn">
                            <i class="fas fa-redo"></i> Reset Game
                        </button>
                    </div>
                </div>
                
                <div class="instructions">
                    <h3><i class="fas fa-info-circle"></i> How to Play</h3>
                    <ul>
                        <li>Use <strong>Arrow Keys</strong> or <strong>WASD</strong> to move the player</li>
                        <li>Collect all <span style="color:#ffd166">gems</span> to unlock the exit</li>
                        <li>Avoid <span style="color:#f72585">monsters</span> or you'll lose health</li>
                        <li>Find the <span style="color:#06d6a0">exit</span> after collecting all gems</li>
                        <li>Press <strong>Space</strong> for a special ability (stuns monsters)</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="game-message" id="gameMessage">
            <h2 id="messageTitle">Game Over</h2>
            <p id="messageText">You won the game!</p>
            <button class="btn btn-primary" id="messageBtn">Play Again</button>
        </div>
        
        <footer>
            <p>Pixel Quest &copy; 2023 | Created with HTML, CSS & JavaScript</p>
        </footer>
    </div>

    <script>
        // Game variables
        const BOARD_SIZE = 15;
        let gameBoard = [];
        let player = { x: 1, y: 1 };
        let gems = [];
        let monsters = [];
        let exit = { x: BOARD_SIZE - 2, y: BOARD_SIZE - 2 };
        let walls = [];
        let gemCount = 0;
        let health = 100;
        let moves = 0;
        let totalGems = 5;
        let gameActive = true;
        let exitUnlocked = false;
        
        // DOM elements
        const gameBoardElement = document.getElementById('gameBoard');
        const gemCountElement = document.getElementById('gemCount');
        const healthCountElement = document.getElementById('healthCount');
        const moveCountElement = document.getElementById('moveCount');
        const monsterCountElement = document.getElementById('monsterCount');
        const gameMessageElement = document.getElementById('gameMessage');
        const messageTitleElement = document.getElementById('messageTitle');
        const messageTextElement = document.getElementById('messageText');
        const messageBtnElement = document.getElementById('messageBtn');
        
        // Initialize the game
        function initGame() {
            // Reset game state
            gameBoard = [];
            gems = [];
            monsters = [];
            walls = [];
            player = { x: 1, y: 1 };
            exit = { x: BOARD_SIZE - 2, y: BOARD_SIZE - 2 };
            gemCount = 0;
            health = 100;
            moves = 0;
            exitUnlocked = false;
            gameActive = true;
            
            // Update UI
            updateStats();
            
            // Generate the game board
            generateBoard();
            generateWalls();
            generateGems();
            generateMonsters();
            
            // Render the board
            renderBoard();
            
            // Hide game message
            gameMessageElement.style.display = 'none';
        }
        
        // Generate the initial board
        function generateBoard() {
            // Create empty board
            for (let y = 0; y < BOARD_SIZE; y++) {
                gameBoard[y] = [];
                for (let x = 0; x < BOARD_SIZE; x++) {
                    gameBoard[y][x] = 'empty';
                }
            }
            
            // Set player position
            gameBoard[player.y][player.x] = 'player';
            
            // Set exit position (initially locked)
            gameBoard[exit.y][exit.x] = 'exit';
        }
        
        // Generate walls in the board
        function generateWalls() {
            // Border walls
            for (let i = 0; i < BOARD_SIZE; i++) {
                walls.push({ x: i, y: 0 });
                walls.push({ x: i, y: BOARD_SIZE - 1 });
                walls.push({ x: 0, y: i });
                walls.push({ x: BOARD_SIZE - 1, y: i });
                
                gameBoard[0][i] = 'wall';
                gameBoard[BOARD_SIZE - 1][i] = 'wall';
                gameBoard[i][0] = 'wall';
                gameBoard[i][BOARD_SIZE - 1] = 'wall';
            }
            
            // Inner walls (maze-like pattern)
            const wallPattern = [
                { x: 3, y: 2 }, { x: 3, y: 3 }, { x: 3, y: 4 },
                { x: 7, y: 5 }, { x: 7, y: 6 }, { x: 7, y: 7 }, { x: 7, y: 8 },
                { x: 5, y: 10 }, { x: 6, y: 10 }, { x: 7, y: 10 },
                { x: 10, y: 3 }, { x: 11, y: 3 }, { x: 12, y: 3 },
                { x: 12, y: 7 }, { x: 12, y: 8 }, { x: 12, y: 9 },
                { x: 8, y: 12 }, { x: 9, y: 12 }, { x: 10, y: 12 }
            ];
            
            wallPattern.forEach(wall => {
                walls.push(wall);
                gameBoard[wall.y][wall.x] = 'wall';
            });
        }
        
        // Generate gems at random positions
        function generateGems() {
            for (let i = 0; i < totalGems; i++) {
                let gemX, gemY;
                do {
                    gemX = Math.floor(Math.random() * (BOARD_SIZE - 2)) + 1;
                    gemY = Math.floor(Math.random() * (BOARD_SIZE - 2)) + 1;
                } while (
                    gameBoard[gemY][gemX] !== 'empty' || 
                    (gemX === player.x && gemY === player.y) ||
                    (gemX === exit.x && gemY === exit.y)
                );
                
                gems.push({ x: gemX, y: gemY });
                gameBoard[gemY][gemX] = 'gem';
            }
        }
        
        // Generate monsters at random positions
        function generateMonsters() {
            const monsterCount = 5;
            
            for (let i = 0; i < monsterCount; i++) {
                let monsterX, monsterY;
                do {
                    monsterX = Math.floor(Math.random() * (BOARD_SIZE - 2)) + 1;
                    monsterY = Math.floor(Math.random() * (BOARD_SIZE - 2)) + 1;
                } while (
                    gameBoard[monsterY][monsterX] !== 'empty' || 
                    (monsterX === player.x && monsterY === player.y) ||
                    (monsterX === exit.x && monsterY === exit.y) ||
                    gems.some(gem => gem.x === monsterX && gem.y === monsterY)
                );
                
                monsters.push({ 
                    x: monsterX, 
                    y: monsterY,
                    direction: Math.random() > 0.5 ? 'horizontal' : 'vertical',
                    moveCounter: 0
                });
                gameBoard[monsterY][monsterX] = 'monster';
            }
            
            // Update monster count display
            monsterCountElement.textContent = monsters.length;
        }
        
        // Render the game board
        function renderBoard() {
            gameBoardElement.innerHTML = '';
            
            for (let y = 0; y < BOARD_SIZE; y++) {
                for (let x = 0; x < BOARD_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = `cell ${gameBoard[y][x]}`;
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    // Add icons for different elements
                    if (gameBoard[y][x] === 'player') {
                        cell.innerHTML = '<i class="fas fa-user"></i>';
                    } else if (gameBoard[y][x] === 'gem') {
                        cell.innerHTML = '<i class="fas fa-gem"></i>';
                    } else if (gameBoard[y][x] === 'monster') {
                        cell.innerHTML = '<i class="fas fa-ghost"></i>';
                    } else if (gameBoard[y][x] === 'exit') {
                        cell.innerHTML = '<i class="fas fa-door-open"></i>';
                    } else if (gameBoard[y][x] === 'wall') {
                        cell.innerHTML = '<i class="fas fa-cube"></i>';
                    }
                    
                    gameBoardElement.appendChild(cell);
                }
            }
        }
        
        // Update game stats display
        function updateStats() {
            gemCountElement.textContent = gemCount;
            healthCountElement.textContent = health;
            moveCountElement.textContent = moves;
            monsterCountElement.textContent = monsters.length;
        }
        
        // Move the player
        function movePlayer(dx, dy) {
            if (!gameActive) return;
            
            const newX = player.x + dx;
            const newY = player.y + dy;
            
            // Check if move is valid (within bounds and not a wall)
            if (
                newX < 0 || newX >= BOARD_SIZE || 
                newY < 0 || newY >= BOARD_SIZE || 
                gameBoard[newY][newX] === 'wall'
            ) {
                return;
            }
            
            // Check if player is trying to exit before collecting all gems
            if (gameBoard[newY][newX] === 'exit' && !exitUnlocked) {
                showMessage("Exit Locked!", "You need to collect all gems before exiting!");
                return;
            }
            
            // Update move count
            moves++;
            
            // Check what's at the new position
            if (gameBoard[newY][newX] === 'gem') {
                // Collect gem
                gemCount++;
                gems = gems.filter(gem => !(gem.x === newX && gem.y === newY));
                
                // Check if all gems collected
                if (gemCount >= totalGems) {
                    exitUnlocked = true;
                    showMessage("Exit Unlocked!", "You collected all gems! Now find the exit!");
                }
            } else if (gameBoard[newY][newX] === 'monster') {
                // Hit a monster
                health -= 20;
                monsters = monsters.filter(monster => !(monster.x === newX && monster.y === newY));
                
                if (health <= 0) {
                    health = 0;
                    gameOver(false);
                }
            } else if (gameBoard[newY][newX] === 'exit' && exitUnlocked) {
                // Reached the exit
                gameOver(true);
            }
            
            // Update game board
            gameBoard[player.y][player.x] = 'empty';
            player.x = newX;
            player.y = newY;
            gameBoard[player.y][player.x] = 'player';
            
            // Move monsters
            moveMonsters();
            
            // Update UI
            updateStats();
            renderBoard();
        }
        
        // Move monsters randomly
        function moveMonsters() {
            monsters.forEach(monster => {
                // Remove monster from current position
                gameBoard[monster.y][monster.x] = 'empty';
                
                // Determine new position based on direction
                let newX = monster.x;
                let newY = monster.y;
                
                // Monsters move every 2 player moves
                monster.moveCounter++;
                if (monster.moveCounter >= 2) {
                    monster.moveCounter = 0;
                    
                    if (monster.direction === 'horizontal') {
                        newX += Math.random() > 0.5 ? 1 : -1;
                    } else {
                        newY += Math.random() > 0.5 ? 1 : -1;
                    }
                    
                    // Change direction if hitting a wall or going out of bounds
                    if (
                        newX < 1 || newX >= BOARD_SIZE - 1 || 
                        newY < 1 || newY >= BOARD_SIZE - 1 ||
                        gameBoard[newY][newX] === 'wall' ||
                        gameBoard[newY][newX] === 'exit' ||
                        gems.some(gem => gem.x === newX && gem.y === newY)
                    ) {
                        monster.direction = monster.direction === 'horizontal' ? 'vertical' : 'horizontal';
                        newX = monster.x;
                        newY = monster.y;
                    }
                }
                
                // Update monster position
                monster.x = newX;
                monster.y = newY;
                gameBoard[monster.y][monster.x] = 'monster';
                
                // Check if monster caught the player
                if (monster.x === player.x && monster.y === player.y) {
                    health -= 25;
                    monsters = monsters.filter(m => !(m.x === monster.x && m.y === monster.y));
                    
                    if (health <= 0) {
                        health = 0;
                        gameOver(false);
                    }
                }
            });
        }
        
        // Special action (stun monsters)
        function specialAction() {
            if (!gameActive || moves < 5) return;
            
            // Stun all monsters (remove them temporarily)
            const stunCount = Math.min(3, monsters.length);
            
            for (let i = 0; i < stunCount; i++) {
                if (monsters.length > 0) {
                    const index = Math.floor(Math.random() * monsters.length);
                    gameBoard[monsters[index].y][monsters[index].x] = 'empty';
                    monsters.splice(index, 1);
                }
            }
            
            // Update stats and render
            updateStats();
            renderBoard();
            
            showMessage("Special Ability Used!", `You stunned ${stunCount} monster(s)!`);
        }
        
        // Show hint (path to nearest gem)
        function showHint() {
            if (!gameActive || gems.length === 0) return;
            
            // Find the nearest gem
            let nearestGem = null;
            let minDistance = Infinity;
            
            gems.forEach(gem => {
                const distance = Math.abs(gem.x - player.x) + Math.abs(gem.y - player.y);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestGem = gem;
                }
            });
            
            if (nearestGem) {
                // Highlight the nearest gem
                const gemCell = document.querySelector(`.cell[data-x="${nearestGem.x}"][data-y="${nearestGem.y}"]`);
                if (gemCell) {
                    gemCell.style.animation = 'pulse 0.5s 5';
                    setTimeout(() => {
                        gemCell.style.animation = '';
                    }, 2500);
                }
                
                showMessage("Hint", `Nearest gem is ${minDistance} moves away!`);
            }
        }
        
        // Game over
        function gameOver(won) {
            gameActive = false;
            
            if (won) {
                messageTitleElement.textContent = "You Won!";
                messageTextElement.textContent = `Congratulations! You escaped the dungeon with ${gemCount} gems in ${moves} moves!`;
            } else {
                messageTitleElement.textContent = "Game Over";
                messageTextElement.textContent = "You were defeated by the dungeon monsters! Try again!";
            }
            
            gameMessageElement.style.display = 'block';
        }
        
        // Show message
        function showMessage(title, text) {
            messageTitleElement.textContent = title;
            messageTextElement.textContent = text;
            gameMessageElement.style.display = 'block';
            
            // Auto-hide after 2 seconds if not a game over message
            if (gameActive) {
                setTimeout(() => {
                    gameMessageElement.style.display = 'none';
                }, 2000);
            }
        }
        
        // Event listeners
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    movePlayer(1, 0);
                    break;
                case ' ':
                    specialAction();
                    break;
            }
        });
        
        // Mobile controls
        document.getElementById('up-btn').addEventListener('click', () => movePlayer(0, -1));
        document.getElementById('down-btn').addEventListener('click', () => movePlayer(0, 1));
        document.getElementById('left-btn').addEventListener('click', () => movePlayer(-1, 0));
        document.getElementById('right-btn').addEventListener('click', () => movePlayer(1, 0));
        document.getElementById('action-btn').addEventListener('click', specialAction);
        
        // Button controls
        document.getElementById('newGameBtn').addEventListener('click', initGame);
        document.getElementById('resetBtn').addEventListener('click', initGame);
        document.getElementById('hintBtn').addEventListener('click', showHint);
        messageBtnElement.addEventListener('click', () => {
            gameMessageElement.style.display = 'none';
            initGame();
        });
        
        // Initialize the game on load
        window.addEventListener('load', initGame);
    </script>
</body>
</html>